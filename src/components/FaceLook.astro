---
import placeholderImg from "../assets/images/sandy-face-placeholder.webp";
import spriteImg from "../assets/images/sandy-face-grid.webp";
import { Image } from "astro:assets";
---

<style is:global>
  .face-tracker {
    position: relative;
    width: 300px;
    height: 300px;
    background: #f0f0f0;
    border-radius: 1000px;
    overflow: hidden;
    border: 6px solid var(--color-primary);
  }

  .face-sprite {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: 1100% 1100%; /* 11 columns × 11 rows */
    background-repeat: no-repeat;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    pointer-events: none;
  }

  .face-sprite.loaded {
    opacity: 1;
    pointer-events: auto;
  }

  .face-tracker img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .face-debug {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    line-height: 1.4;
    z-index: 10;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .face-tracker {
      width: 250px;
      height: 250px;
    }
  }
</style>
<div
  class="face-tracker shadow-lg mx-auto my-12"
  id="face"
  data-debug="false"
  data-sprite-src={spriteImg.src}
>
  <Image
    src={placeholderImg}
    alt="Sandy's face"
    width={300}
    height={300}
    id="placeholder-image"
    loading="eager"
  />
</div>
<script>
  /**
   * Face Tracker Component
   *
   * Creates an interactive face sprite that follows the user's cursor across the page.
   * Uses an 11x11 sprite sheet grid where each frame shows the face looking in a different direction.
   *
   * Features:
   * - Smooth cursor tracking with immediate response
   * - Progressive image loading (placeholder → sprite sheet)
   * - Touch and mouse support
   * - Optional debug mode showing cursor position and grid coordinates
   * - Memory leak prevention with proper cleanup
   * - Error handling for sprite loading failures
   *
   * How it works:
   * 1. Loads a low-res placeholder image first for instant visibility
   * 2. Preloads the sprite sheet in the background
   * 3. Converts cursor position to normalized coordinates [-1, 1]
   * 4. Maps coordinates to grid indices [0, 10]
   * 5. Updates background-position to show the correct sprite frame
   * 6. Fades out placeholder once sprite is loaded
   */

  // Sprite grid configuration
  const GRID_SIZE = 11; // 11x11 grid

  function clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  function normalizedToGridIndex(normalized: number): number {
    // Convert [-1, 1] to [0, GRID_SIZE-1]
    // -1 maps to 0, 0 maps to 5, 1 maps to 10
    const index = Math.round(((normalized + 1) / 2) * (GRID_SIZE - 1));
    return clamp(index, 0, GRID_SIZE - 1);
  }

  function updateDebug(
    debugEl: HTMLElement | null,
    x: number,
    y: number,
    col: number,
    row: number
  ): void {
    if (!debugEl) return;
    debugEl.innerHTML = `Mouse: (${Math.round(x)}, ${Math.round(y)})<br/>Grid: col ${col}, row ${row}`;
  }

  function initializeFaceTracker(container: HTMLElement): void {
    const showDebug = container.dataset.debug === "true";
    const spriteSrc = container.dataset.spriteSrc || "";

    if (!spriteSrc) {
      console.error("Sprite source not provided");
      return;
    }

    // Get the placeholder image element
    const placeholderImg = container.querySelector<HTMLImageElement>("img");
    if (!placeholderImg) {
      console.error("Placeholder image not found");
      return;
    }

    // Create sprite div
    const spriteDiv = document.createElement("div");
    spriteDiv.className = "face-sprite";
    spriteDiv.setAttribute("role", "img");
    spriteDiv.setAttribute("aria-label", "Sandy's face following your cursor");
    container.appendChild(spriteDiv);

    let debugEl: HTMLElement | null = null;
    if (showDebug) {
      debugEl = document.createElement("div");
      debugEl.className = "face-debug";
      container.appendChild(debugEl);
    }

    let spriteLoaded = false;

    // Preload sprite sheet
    const spriteImage = new Image();

    spriteImage.onerror = () => {
      console.error("Failed to load sprite image:", spriteSrc);
      spriteDiv.remove();
      if (debugEl) debugEl.remove();
    };

    spriteImage.onload = () => {
      spriteLoaded = true;
      spriteDiv.style.backgroundImage = `url("${spriteSrc}")`;
      spriteDiv.style.backgroundPosition = "50% 50%"; // Start centered

      // Listen for transition end to remove placeholder
      const handleTransitionEnd = (e: TransitionEvent) => {
        if (e.propertyName === "opacity" && e.target === spriteDiv) {
          placeholderImg?.remove();
          spriteDiv.removeEventListener("transitionend", handleTransitionEnd);
        }
      };
      spriteDiv.addEventListener("transitionend", handleTransitionEnd);

      spriteDiv.classList.add("loaded");

      // Trigger initial position update
      const rect = container.getBoundingClientRect();
      setFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
    };

    spriteImage.src = spriteSrc;

    function setFromClient(clientX: number, clientY: number): void {
      if (!spriteLoaded) return;

      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Normalize to [-1, 1] range
      const nx = (clientX - centerX) / (rect.width / 2);
      const ny = (centerY - clientY) / (rect.height / 2); // Inverted Y

      const clampedX = clamp(nx, -1, 1);
      const clampedY = clamp(ny, -1, 1);

      // Convert to grid indices
      // X: -1 (left) = col 0, +1 (right) = col 10
      // Y: +1 (up) = row 0 (top of sprite), -1 (down) = row 10 (bottom of sprite)
      const col = normalizedToGridIndex(clampedX);
      const row = normalizedToGridIndex(clampedY);

      // Calculate background position
      const xPercent = (col / (GRID_SIZE - 1)) * 100;
      const yPercent = (row / (GRID_SIZE - 1)) * 100;

      spriteDiv.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
      updateDebug(debugEl, clientX - rect.left, clientY - rect.top, col, row);
    }

    function handleMouseMove(e: MouseEvent): void {
      setFromClient(e.clientX, e.clientY);
    }

    function handleTouchMove(e: TouchEvent): void {
      const touch = e.touches[0];
      if (!touch) return;
      setFromClient(touch.clientX, touch.clientY);
    }

    // Track pointer anywhere on the page
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("touchmove", handleTouchMove, { passive: true });

    // Cleanup function to prevent memory leaks
    const cleanup = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("touchmove", handleTouchMove);
    };

    // Store cleanup function on the container for potential future cleanup
    (container as any).__faceTrackerCleanup = cleanup;
  }

  function initFaceTrackers() {
    // Clean up any existing trackers first to prevent duplicates
    document.querySelectorAll<HTMLElement>(".face-tracker").forEach((el) => {
      // Remove event listeners
      const cleanup = (el as any).__faceTrackerCleanup;
      if (cleanup) {
        cleanup();
        delete (el as any).__faceTrackerCleanup;
      }
      // Remove any existing sprite divs that might have been added
      const existingSprite = el.querySelector(".face-sprite");
      if (existingSprite) existingSprite.remove();
      const existingDebug = el.querySelector(".face-debug");
      if (existingDebug) existingDebug.remove();
    });

    // Small delay to ensure DOM is fully ready after view transition swap
    // This is especially important for astro:page-load events
    requestAnimationFrame(() => {
      // Initialize all face trackers
      document
        .querySelectorAll<HTMLElement>(".face-tracker")
        .forEach((el) => initializeFaceTracker(el));
    });
  }

  // Handle initial page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initFaceTrackers);
  } else {
    // DOM already loaded, initialize immediately
    initFaceTrackers();
  }

  // Handle Astro view transitions navigation
  // This fires on every navigation when view transitions are enabled
  document.addEventListener("astro:page-load", initFaceTrackers);

  // Optional: Add cleanup on page unload for SPA-like behavior
  if (typeof window !== "undefined") {
    window.addEventListener("beforeunload", () => {
      document.querySelectorAll<HTMLElement>(".face-tracker").forEach((el) => {
        const cleanup = (el as any).__faceTrackerCleanup;
        if (cleanup) cleanup();
      });
    });
  }
</script>
