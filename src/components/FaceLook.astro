---
import placeholderImg from "../assets/images/sandy-face-placeholder.webp";
import spriteImg from "../assets/images/sandy-face-grid.webp";
import { Image } from "astro:assets";
---

<style is:global>
  .face-tracker {
    position: relative;
    width: 300px;
    height: 300px;
    background: #f0f0f0;
    border-radius: 1000px;
    overflow: hidden;
    border: 6px solid var(--color-primary);
    flex: none;
    cursor: none;
  }

  .fly-cursor-face {
    position: fixed;
    width: 32px;
    height: 32px;
    background: url("/fly.svg") center/contain no-repeat;
    pointer-events: none;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.15s ease;
  }

  .fly-cursor-face.visible {
    opacity: 1;
  }

  /* Accessibility: reduced motion – static face, no fly cursor, instant transitions */
  @media (prefers-reduced-motion: reduce) {
    .face-tracker {
      cursor: auto;
    }

    .fly-cursor-face {
      display: none;
    }

    .face-sprite {
      transition: none;
    }
  }

  /* Touch/coarse pointer: no fly cursor; fallback for when JS hasn't created it yet */
  @media (hover: none), (pointer: coarse) {
    .face-tracker {
      cursor: auto;
    }

    .fly-cursor-face {
      display: none;
    }
  }

  /* Accessibility: reduced transparency – instant sprite fade, no opacity transition */
  @media (prefers-reduced-transparency: reduce) {
    .face-sprite {
      transition: none;
    }
  }

  .face-sprite {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: 1100% 1100%; /* 11 columns × 11 rows */
    background-repeat: no-repeat;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    pointer-events: none;
  }

  .face-sprite.loaded {
    opacity: 1;
    pointer-events: auto;
  }

  .face-tracker img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .face-debug {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    line-height: 1.4;
    z-index: 10;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .face-tracker {
      width: 250px;
      height: 250px;
    }
  }
</style>
<div
  class="face-tracker shadow-lg mx-auto my-12"
  id="face"
  data-debug="false"
  data-sprite-src={spriteImg.src}
>
  <Image
    src={placeholderImg}
    alt="Sandy's face"
    width={300}
    height={300}
    id="placeholder-image"
    loading="eager"
  />
</div>
<script>
  /**
   * Face Tracker Component
   *
   * Creates an interactive face sprite that follows the user's cursor across the page.
   * Uses an 11x11 sprite sheet grid where each frame shows the face looking in a
   * different direction.
   *
   * Features:
   * - Face sprite tracking: smooth cursor/pointer tracking with immediate response
   * - Fly cursor (desktop only): custom fly image replaces cursor when hovering face
   * - Fly sound (desktop only): looping buzz plays while hovering face
   * - Progressive image loading: placeholder → sprite sheet
   * - Mouse and touch support for face tracking; fly cursor/sound on pointer devices only
   * - Accessibility: respects prefers-reduced-motion (static face, no fly, no sound)
   * - Optional debug mode: cursor position and grid coordinates
   * - Astro view transitions support (re-initializes on navigation)
   *
   * Lifecycle & Navigation:
   * - Listens to DOMContentLoaded (initial load) and astro:page-load (view transitions)
   * - Re-initializes when prefers-reduced-motion changes
   * - Cleans up event listeners and DOM before re-initializing
   * - Uses requestAnimationFrame for DOM readiness after view transition swaps
   *
   * Face sprite flow:
   * 1. Load placeholder image for instant visibility
   * 2. Preload sprite sheet in background
   * 3. Convert cursor position to normalized [-1, 1]
   * 4. Map to grid indices [0, 10] and update background-position
   * 5. Fade out placeholder when sprite loads
   *
   * Fly cursor/sound (desktop/pointer devices only, when not reduced-motion):
   * - Custom fly cursor shown when hovering face; buzzing sound loops
   * - Audio requires user gesture (click/tap) to unlock; one-time listeners handle this
   * - Touch devices: fly and sound disabled; face tracking still works via touch
   */

  const GRID_SIZE = 11; // 11×11 sprite sheet (121 frames)

  function clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  function normalizedToGridIndex(normalized: number): number {
    // Convert [-1, 1] to [0, GRID_SIZE-1]
    // -1 maps to 0, 0 maps to 5, 1 maps to 10
    const index = Math.round(((normalized + 1) / 2) * (GRID_SIZE - 1));
    return clamp(index, 0, GRID_SIZE - 1);
  }

  function updateDebug(
    debugEl: HTMLElement | null,
    x: number,
    y: number,
    col: number,
    row: number,
  ): void {
    if (!debugEl) return;
    debugEl.innerHTML = `Mouse: (${Math.round(x)}, ${Math.round(y)})<br/>Grid: col ${col}, row ${row}`;
  }

  /** True when user has enabled reduced motion in OS/browser settings. */
  function prefersReducedMotion(): boolean {
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  }

  /** True when device has fine pointer (e.g. mouse) and can hover; false for touch-only. */
  function isPointerDevice(): boolean {
    return window.matchMedia("(hover: hover) and (pointer: fine)").matches;
  }

  function initializeFaceTracker(container: HTMLElement): void {
    const showDebug = container.dataset.debug === "true";
    const spriteSrc = container.dataset.spriteSrc || "";
    const reducedMotion = prefersReducedMotion();

    if (!spriteSrc) {
      console.error("Sprite source not provided");
      return;
    }

    // Get the placeholder image element
    const placeholderImg = container.querySelector<HTMLImageElement>("img");
    if (!placeholderImg) {
      console.error("Placeholder image not found");
      return;
    }

    // Create sprite div
    const spriteDiv = document.createElement("div");
    spriteDiv.className = "face-sprite";
    spriteDiv.setAttribute("role", "img");
    spriteDiv.setAttribute(
      "aria-label",
      reducedMotion ? "Sandy's face" : "Sandy's face following your cursor",
    );
    container.appendChild(spriteDiv);

    let debugEl: HTMLElement | null = null;
    if (showDebug) {
      debugEl = document.createElement("div");
      debugEl.className = "face-debug";
      container.appendChild(debugEl);
    }

    let spriteLoaded = false;

    // Preload sprite sheet
    const spriteImage = new Image();

    spriteImage.onerror = () => {
      console.error("Failed to load sprite image:", spriteSrc);
      spriteDiv.remove();
      if (debugEl) debugEl.remove();
    };

    spriteImage.onload = () => {
      spriteLoaded = true;
      spriteDiv.style.backgroundImage = `url("${spriteSrc}")`;
      spriteDiv.style.backgroundPosition = "50% 50%"; // Start centered

      // Listen for transition end to remove placeholder
      const handleTransitionEnd = (e: TransitionEvent) => {
        if (e.propertyName === "opacity" && e.target === spriteDiv) {
          placeholderImg?.remove();
          spriteDiv.removeEventListener("transitionend", handleTransitionEnd);
        }
      };
      spriteDiv.addEventListener("transitionend", handleTransitionEnd);

      spriteDiv.classList.add("loaded");

      // Trigger initial position update
      const rect = container.getBoundingClientRect();
      setFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
    };

    spriteImage.src = spriteSrc;

    function setFromClient(clientX: number, clientY: number): void {
      if (!spriteLoaded || reducedMotion) return;

      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Normalize to [-1, 1] range
      const nx = (clientX - centerX) / (rect.width / 2);
      const ny = (centerY - clientY) / (rect.height / 2); // Inverted Y

      const clampedX = clamp(nx, -1, 1);
      const clampedY = clamp(ny, -1, 1);

      // Convert to grid indices
      // X: -1 (left) = col 0, +1 (right) = col 10
      // Y: +1 (up) = row 0 (top of sprite), -1 (down) = row 10 (bottom of sprite)
      const col = normalizedToGridIndex(clampedX);
      const row = normalizedToGridIndex(clampedY);

      // Calculate background position
      const xPercent = (col / (GRID_SIZE - 1)) * 100;
      const yPercent = (row / (GRID_SIZE - 1)) * 100;

      spriteDiv.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
      updateDebug(debugEl, clientX - rect.left, clientY - rect.top, col, row);
    }

    // Fly cursor and sound: desktop/pointer devices only; skipped when reduced-motion
    const pointerDevice = isPointerDevice();
    let flyCursor: HTMLElement | null = null;
    let flySound: HTMLAudioElement | null = null;
    let unlockAudio: (() => void) | null = null;

    if (pointerDevice && !reducedMotion) {
      flyCursor = document.createElement("div");
      flyCursor.className = "fly-cursor-face";
      flyCursor.setAttribute("aria-hidden", "true");
      document.body.appendChild(flyCursor);

      flySound = new Audio("/fly.mp3");
      flySound.loop = true;
      flySound.volume = 0.25;

      // Browsers require user gesture (click/tap) before audio can play. Hover does not count.
      // Unlock on first click/tap so subsequent hover-triggered play() succeeds.
      unlockAudio = () => {
        if (flySound) {
          flySound
            .play()
            .then(() => flySound!.pause())
            .catch(() => {});
          document.removeEventListener("click", unlockAudio!);
          document.removeEventListener("touchstart", unlockAudio!);
        }
      };
      document.addEventListener("click", unlockAudio, { once: true });
      document.addEventListener("touchstart", unlockAudio, { once: true });
    }

    function handleMouseMove(e: MouseEvent): void {
      setFromClient(e.clientX, e.clientY);
      if (flyCursor && flySound) {
        const rect = container.getBoundingClientRect();
        const isOver =
          e.clientX >= rect.left &&
          e.clientX <= rect.right &&
          e.clientY >= rect.top &&
          e.clientY <= rect.bottom;
        if (isOver) {
          flyCursor.style.left = `${e.clientX - 16}px`;
          flyCursor.style.top = `${e.clientY - 16}px`;
          flyCursor.classList.add("visible");
          flySound.play().catch(() => {});
        } else {
          flyCursor.classList.remove("visible");
          flySound.pause();
        }
      }
    }

    function handleTouchMove(e: TouchEvent): void {
      const touch = e.touches[0];
      if (!touch) return;
      setFromClient(touch.clientX, touch.clientY);
    }

    // Track pointer anywhere on the page
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("touchmove", handleTouchMove, { passive: true });

    // Cleanup function to prevent memory leaks
    const cleanup = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("touchmove", handleTouchMove);
      if (unlockAudio) {
        document.removeEventListener("click", unlockAudio);
        document.removeEventListener("touchstart", unlockAudio);
      }
      if (flySound) flySound.pause();
      if (flyCursor) flyCursor.remove();
    };

    (container as any).__faceTrackerCleanup = cleanup;
  }

  /**
   * Initialize or re-initialize all face trackers on the page.
   * Called on: initial load (DOMContentLoaded), view transitions (astro:page-load),
   * and when prefers-reduced-motion changes.
   * Cleans up existing trackers before re-init to prevent duplicate listeners.
   */
  function initFaceTrackers() {
    document.querySelectorAll<HTMLElement>(".face-tracker").forEach((el) => {
      const cleanup = (el as any).__faceTrackerCleanup;
      if (cleanup) {
        cleanup();
        delete (el as any).__faceTrackerCleanup;
      }
      const existingSprite = el.querySelector(".face-sprite");
      if (existingSprite) existingSprite.remove();
      const existingDebug = el.querySelector(".face-debug");
      if (existingDebug) existingDebug.remove();
    });

    requestAnimationFrame(() => {
      document
        .querySelectorAll<HTMLElement>(".face-tracker")
        .forEach(initializeFaceTracker);
    });
  }

  // Init on load, navigation, and when reduced-motion preference changes
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initFaceTrackers);
  } else {
    initFaceTrackers();
  }
  document.addEventListener("astro:page-load", initFaceTrackers);

  if (typeof window !== "undefined") {
    window.addEventListener("beforeunload", () => {
      document.querySelectorAll<HTMLElement>(".face-tracker").forEach((el) => {
        const cleanup = (el as any).__faceTrackerCleanup;
        if (cleanup) cleanup();
      });
    });
  }
</script>
