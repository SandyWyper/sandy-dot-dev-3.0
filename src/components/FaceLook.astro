---
import placeholderImg from "../assets/images/sandy-face-placeholder.webp";
import spriteImg from "../assets/images/sandy-face-grid.webp";
---

<style is:global>
  .face-tracker {
    position: relative;
    width: 300px;
    height: 300px;
    background: #f0f0f0;
    border-radius: 1000px;
    overflow: hidden;
    border: 6px solid var(--color-primary);
  }

  .face-sprite {
    width: 100%;
    height: 100%;
    background-size: 1100% 1100%; /* 11 columns Ã— 11 rows */
    background-repeat: no-repeat;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }

  .face-sprite.loading {
    background-size: cover;
    background-position: center;
  }

  .face-debug {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    line-height: 1.4;
    z-index: 10;
  }
  .loading-ring {
    mask-image: url("data:image/svg+xml,%3Csvg width='44' height='44' viewBox='0 0 44 44' xmlns='http://www.w3.org/2000/svg' stroke='white'%3E%3Cg fill='rgba(0, 0, 0, 0.4)' fill-rule='evenodd' stroke-width='2'%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='0s' dur='1.8s' values='1;20' calcMode='spline' keyTimes='0;1' keySplines='0.165,0.84,0.44,1' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-opacity' begin='0s' dur='1.8s' values='1;0' calcMode='spline' keyTimes='0;1' keySplines='0.3,0.61,0.355,1' repeatCount='indefinite'/%3E%3C/circle%3E%3Ccircle cx='22' cy='22' r='1'%3E%3Canimate attributeName='r' begin='-0.9s' dur='1.8s' values='1;20' calcMode='spline' keyTimes='0;1' keySplines='0.165,0.84,0.44,1' repeatCount='indefinite'/%3E%3Canimate attributeName='stroke-opacity' begin='-0.9s' dur='1.8s' values='1;0' calcMode='spline' keyTimes='0;1' keySplines='0.3,0.61,0.355,1' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E") !important;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .face-tracker {
      width: 250px;
      height: 250px;
    }
  }
</style>
<div
  class="face-tracker shadow-lg mx-auto my-12"
  id="face"
  data-debug="false"
  data-placeholder-src={placeholderImg.src}
  data-sprite-src={spriteImg.src}
>
</div>
<script>
  // Sprite grid configuration
  const GRID_SIZE = 11; // 11x11 grid
  const GRID_COLS = 11;
  const GRID_ROWS = 11;

  function clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value));
  }

  function normalizedToGridIndex(normalized: number): number {
    // Convert [-1, 1] to [0, GRID_SIZE-1]
    // -1 maps to 0, 0 maps to 5, 1 maps to 10
    const index = Math.round(((normalized + 1) / 2) * (GRID_SIZE - 1));
    return clamp(index, 0, GRID_SIZE - 1);
  }

  function updateDebug(
    debugEl: HTMLElement | null,
    x: number,
    y: number,
    col: number,
    row: number
  ): void {
    if (!debugEl) return;
    debugEl.innerHTML = `Mouse: (${Math.round(x)}, ${Math.round(y)})<br/>Grid: col ${col}, row ${row}`;
  }

  function initializeFaceTracker(container: HTMLElement): void {
    const showDebug = String(container.dataset.debug || "false") === "true";
    const placeholderSrc = container.dataset.placeholderSrc || "";
    const spriteSrc = container.dataset.spriteSrc || "";

    // Create sprite div with placeholder background
    const spriteDiv = document.createElement("div");
    spriteDiv.className = "face-sprite loading loading-ring loading-lg";
    spriteDiv.style.backgroundImage = `url("${placeholderSrc}")`;
    spriteDiv.style.width = "100%";
    spriteDiv.style.height = "100%";
    spriteDiv.style.backgroundSize = "cover";
    spriteDiv.style.backgroundPosition = "center";
    spriteDiv.setAttribute("role", "img");
    spriteDiv.setAttribute("aria-label", "Sandy's face following your cursor");
    container.appendChild(spriteDiv);

    let debugEl: HTMLElement | null = null;
    if (showDebug) {
      debugEl = document.createElement("div");
      debugEl.className = "face-debug";
      container.appendChild(debugEl);
    }

    let spriteLoaded = false;

    // Preload sprite sheet
    const spriteImage = new Image();
    spriteImage.onload = () => {
      spriteLoaded = true;
      spriteDiv.style.backgroundImage = `url("${spriteSrc}")`;
      spriteDiv.style.backgroundSize = "1100% 1100%"; // 11x11 grid
      spriteDiv.style.backgroundPosition = "50% 50%"; // Start centered
      spriteDiv.classList.remove("loading");
      spriteDiv.classList.remove("loading-ring");

      // Trigger initial position update
      const rect = container.getBoundingClientRect();
      setFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
    };
    spriteImage.src = spriteSrc;

    function setFromClient(clientX: number, clientY: number): void {
      if (!spriteLoaded) return;

      const rect = container.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Normalize to [-1, 1] range
      const nx = (clientX - centerX) / (rect.width / 2);
      const ny = (centerY - clientY) / (rect.height / 2); // Inverted Y

      const clampedX = clamp(nx, -1, 1);
      const clampedY = clamp(ny, -1, 1);

      // Convert to grid indices
      // X: -1 (left) = col 0, +1 (right) = col 10
      // Y: +1 (up) = row 0 (top of sprite), -1 (down) = row 10 (bottom of sprite)
      const col = normalizedToGridIndex(clampedX);
      const row = normalizedToGridIndex(clampedY);

      // Calculate background position
      // Each sprite is 1/(GRID_SIZE-1) of the total
      const xPercent = (col / (GRID_COLS - 1)) * 100;
      const yPercent = (row / (GRID_ROWS - 1)) * 100;

      spriteDiv.style.backgroundPosition = `${xPercent}% ${yPercent}%`;
      updateDebug(debugEl, clientX - rect.left, clientY - rect.top, col, row);
    }

    function handleMouseMove(e: MouseEvent): void {
      setFromClient(e.clientX, e.clientY);
    }

    function handleTouchMove(e: TouchEvent): void {
      if (e.touches && e.touches.length > 0) {
        const t = e.touches[0];
        setFromClient(t.clientX, t.clientY);
      }
    }

    // Track pointer anywhere on the page
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("touchmove", handleTouchMove, { passive: true });
  }

  document.addEventListener("DOMContentLoaded", () => {
    document
      .querySelectorAll<HTMLElement>(".face-tracker")
      .forEach((el) => initializeFaceTracker(el));
  });
</script>
